---
title: "Regulon NMF"
author: "HDSU"
date: "`r date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    number_sections: false
params:
  K                   : 8
  maxRank             : 20
  n_initializations   : 3
  p_exprs             : '/home/bq_aquintero/projects/mouse_atlas_TF_activity/data/scrna/Han_atlas/MCA_Adult_9Tissues_Seurat.RDS'
  p_regulon           : "/home/bq_aquintero/projects/mouse_atlas_TF_activity/adult_9tissues/results/integrated/TF_activity_method2_500000/regulonAUC.RDS"
  sampleregulon: FALSE
  p_nmf : "/home/bq_aquintero/projects/mouse_atlas_TF_activity/adult_9tissues/results/integrated/TF_activity_method2_500000/NMF_whole/NMF_regulonAUC.RDS"
  annotCol: "tissue"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
#this chunk sets global options for Rmarkdown

knitr::opts_chunk$set(echo = TRUE)
options(knitr.table.format="html")

# if (Sys.info()[["sysname"]] == "Darwin") {
#     # When running locally use conda env
#     reticulate::use_condaenv("tensor240pip", required = TRUE)
#     print(reticulate::py_config())
# }

library(tidyverse)
library(Polychrome)
library(viridis)
library(ComplexHeatmap)
#library(DESeq2)
library(ButchR)
#library(ggupset)
#library(clusterProfiler)
#library(msigdbr)
library(umap)
library(cowplot)
library(MatrixGenerics)


```

## NMF of a recovered regulon

Only cells for wich the corresponding cell type was found in scATAC-seq data are taken into account.


## Preprocessing   

Load data and filter out cell 


```{r preprocess,  fig.width=12, fig.height=12, out.width="90%"}

# params <- list(K = 8,
#                p_exprs = 'results/scrna/seurat/rna_seurat_int_annot_transfer.RDS',
#                p_regulon = "results/integrated/TF_activity/regulonAUC.RDS",
#                p_regulonAUC_devCor = "results/integrated/TF_activity/regulonAUC_devCorrected.RDS")



regulon <- readRDS(params$p_regulon)
dim(regulon)

table(rowSums(regulon) == 0)
table(colSums(regulon) == 0)

exprs <- readRDS(params$p_exprs)
```

## Applying NMF

Applying Non-Negative Matrix Factorization (NMF) to Regulon, using:  
- Factorization ranks from 2 to 8.
- Default NMF method.
- 10 random initialization.

```{r NMF_run, message=FALSE, warning=FALSE, cache=FALSE}
##----------------------------------------------------------------------------##
##                             run NMF                                        ##
##----------------------------------------------------------------------------##
factorization_ranks <- 2:params$maxRank
#factorization_ranks <- 7:8
# nmf_exp <- run_NMF_tensor(X                     = regulon,
#                           ranks                 = factorization_ranks,
#                           method                = "NMF",
#                           n_initializations     = params$n_initializations,
#                           iterations            = 10^4,
#                           convergence_threshold = 40, 
#                           extract_features = TRUE)
# nmf_exp
#   
# ## Normalize NMF
# norm_nmf_exp <- normalizeW(nmf_exp)

# saveRDS(norm_nmf_exp, params$p_nmf)

norm_nmf_exp <- readRDS(params$p_nmf)

```
 
 
## Factorization quality metrics and optimal K

Based on the results of the factorization quality metrics, an optimal number of signatures (k) must be chosen:
  
```{r NMF_optK, results='hide',fig.keep='all', message=FALSE, warning=FALSE}
## Plot K stats
gg_plotKStats(norm_nmf_exp)

```
Minize the Frobenius error, the coefficient of variation and the mean Amari distance, while maximizing the sum and mean silhouette width and the cophenic coefficient.
  


## H Matrix sample exposure:  {.tabset}  

Visualization of the sample exposure to the decomposed signatures.
  
  
```{r Hmatrix_Wnorm, fig.width=8, fig.height=5.5, out.width="90%", results='asis', warning=FALSE, message=FALSE}

Heatmap_Regulon <- function(regulon, seurat, title, colID){
  
  set.seed(1)
  idx <- sample(colnames(regulon), size=10000, replace=FALSE)
  regulon <- regulon[,idx]
  
  type.colVector <- seurat@meta.data[,colID, drop=FALSE] %>% 
    dplyr::distinct() %>% 
    #dplyr::rename(Celltype =  !!enquo(colID)) %>% 
    dplyr::rename(Celltype =  !!colID) %>% 
    dplyr::arrange(Celltype) %>% 
    dplyr::mutate(color = alphabet.colors(n())) %>% 
    deframe()
  collist <- list(type.colVector) 
  names(collist) <- colID
  
  # Build Heatmap annotation
  heat.anno <- HeatmapAnnotation(df  = seurat@meta.data[colnames(regulon),colID, drop=FALSE],
                                 col = collist,
                                 #list(predicted.id = type.colVector),
                                 show_annotation_name = TRUE, na_col = "white")
  
  

  
  
  rownames(regulon) <- paste0("Sign.", 1:nrow(regulon))
  Heatmap(regulon,
          col = viridis(100),
          name = title,
          top_annotation = heat.anno,
          use_raster = TRUE,
          raster_device = "png",
          show_column_names = FALSE,
          show_row_names = TRUE,
          show_column_dend = FALSE,
          show_row_dend = FALSE,
          cluster_rows = TRUE)
}


##----------------------------------------------------------------------------##
##              Generate H matrix heatmap, W normalized                       ##
##----------------------------------------------------------------------------##
heatmaps_list <- list()
i <- 1
for(ki in factorization_ranks) {
  cat("\n")
  cat("  \n### H matrix for k=",  ki, "  {.tabset}   \n  ")
  #plot H matrix
  tmpHmatrix <- HMatrix(norm_nmf_exp, k = ki)
  h.heatmap <- Heatmap_Regulon(regulon=tmpHmatrix, seurat=exprs, title=paste0("H k=", ki), colID=params$annotCol)
  print(h.heatmap)
  heatmaps_list[[i]] <- h.heatmap
  
  h.heatmap <- Heatmap_Regulon(regulon=tmpHmatrix/rowMaxs(tmpHmatrix), seurat=exprs, title=paste0("H k=", ki), colID=params$annotCol)
  print(h.heatmap)
  heatmaps_list[[i+1]] <- h.heatmap
  i <- i+2
}


#length(heatmaps_list)
pdf(file = sub(".RDS", "_heatmaps.pdf", params$p_nmf), width=10, height=7)
for (h in heatmaps_list) {
  print(h)
}
dev.off()


```

## Signature estability - Riverplot visualization

Riverplot representation of the extracted signatures at different factorization ranks. The nodes represent the signatures, the edge strength encodes cosine similarity between signatures linked by the edges. 

```{r NMF_river, results='hide',fig.keep='all', message=FALSE, warning=FALSE}
river <- generateRiverplot(norm_nmf_exp, ranks = factorization_ranks)
plot(river, plot_area=1, yscale=0.6, nodewidth=0.5)


pdf(file = sub(".RDS", "_riverplot.pdf", params$p_nmf), width=10, height=7)
plot(river, plot_area=1, yscale=0.6, nodewidth=0.5)
dev.off()


```


## Cluster identification - UMAP

Cluster identification by running UMAP on the matrix H. 

```{r umap_Hmatrix}
##----------------------------------------------------------------------------##
##                         UMAP H matrix                                      ##
##----------------------------------------------------------------------------##
hmatrix_norm <- HMatrix(norm_nmf_exp, k = params$K)
umapView <- umap(t(hmatrix_norm))

umapView_df <- as.data.frame(umapView$layout)
colnames(umapView_df) <- c("UMAP1", "UMAP2")

umapView_df %>% 
  rownames_to_column("cellID") %>% 
  left_join(rownames_to_column(exprs@meta.data, "cellID"), by = "cellID") %>% 
  ggplot(aes(x=UMAP1, y=UMAP2, color = !!sym(params$annotCol))) + 
  geom_point(size = 1.5, alpha = 0.95) + 
  #scale_color_manual(values = type_colVector) +
  cowplot::theme_cowplot()


```

## Association of signatures to biological variables:  {.tabset}  


Recovery plots showing the association of the NMF signatures to known biological variables.
  
  
```{r recovery, fig.width=8, fig.height=5.5, out.width="90%", results='asis', warning=FALSE, message=FALSE}
##----------------------------------------------------------------------------##
##                               Recovery plots                               ##
##----------------------------------------------------------------------------##

annot <- umapView_df %>% 
  rownames_to_column("cellID") %>% 
  left_join(rownames_to_column(exprs@meta.data, "cellID"), by = "cellID")

recovery_list <- list()
i <- 1
for(ki in factorization_ranks) {
  cat("\n")
  cat("  \n### Recovery plots for k=",  ki, "  {.tabset}   \n  ")
  tmpHmatrix <- HMatrix(norm_nmf_exp, k = ki)
  recov <- ButchR::recovery_plot(tmpHmatrix, annot[, params$annotCol])
  print(recov)
  recovery_list[[i]] <- recov
  i <- i+1
}

saveRDS(recovery_list, sub(".RDS", "_recovery_list.RDS", params$p_nmf))

length(recovery_list)
pdf(file = sub(".RDS", "_recovery.pdf", params$p_nmf), width=10, height=7)
for (recov in recovery_list) {
  plot(recov)
}
dev.off()

```


```{r}

# How to correct signif in recovery plot
ggrecov <- readRDS("/home/bq_aquintero/projects/mouse_atlas_TF_activity/adult_9tissues/results/integrated/TF_activity_method2_500000/NMF_whole/NMF_regulonAUC_recovery_list.RDS")
length(ggrecov)

df <- ggrecov[[10]]$data

2^11

df %>% 
  group_by(Annotation_level, SignatureID) %>% 
  #summarise(n = n())
  mutate(qval = .data$p*n()*11) %>% 
  #summarize(qval = unique(qval)) %>% 
  mutate(issignif = (.data$p*(n()^11)) < 0.05) %>%
  #head()
  ggplot(aes(x = .data$Rank, y = .data$Frequency, color = .data$SignatureID,
           linetype = .data$issignif, size = .data$issignif)) +
  
  
  # geom_step(data = function(x){x %>% filter(!issignif)}, size  = 0.5) +
  # geom_step(data = function(x){x %>% filter(issignif)}, size  = 1.5) +
  geom_step() +
  
  geom_abline(intercept = 0, slope = 1/56265) +
  facet_wrap(.~Annotation_level) +
  # chance line style
  scale_linetype_manual(name = c("Significant p-val<0.05"),
                        values = c("TRUE" = 1, "FALSE" = 2)) +
  scale_size_manual(name = c("Significant p-val<0.05"),
                    values = c("TRUE" = 1, "FALSE" = 0.5)) +
  #theme_bw() +
  theme_cowplot() +
  panel_border(color = "grey40", size = 1, linetype = 1,
               remove = FALSE)

```

