---
title: "Regulon NMF"
author: "HDSU"
date: "`r date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    number_sections: false
params:
  K                   : 5
  maxRank             : 6
  n_initializations   : 3
  p_exprs             : '/home/bq_aquintero/projects/mouse_atlas_TF_activity/data/scrna/Han_atlas/MCA_Adult_9Tissues_Seurat.RDS'
  p_regulon           : "/home/bq_aquintero/projects/mouse_atlas_TF_activity/adult_9tissues/results/integrated/TF_activity_method2_500000/regulonAUC.RDS"
  sampleregulon: FALSE
  p_nmf : "/home/bq_aquintero/projects/mouse_atlas_TF_activity/adult_9tissues/results/integrated/TF_activity_method2_500000/NMF_whole/NMF_regulonAUC.RDS"
  annotCol: "tissue"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
#this chunk sets global options for Rmarkdown

knitr::opts_chunk$set(echo = TRUE)
options(knitr.table.format="html")

# if (Sys.info()[["sysname"]] == "Darwin") {
#     # When running locally use conda env
#     reticulate::use_condaenv("tensor240pip", required = TRUE)
#     print(reticulate::py_config())
# }

library(tidyverse)
library(Polychrome)
library(viridis)
library(ComplexHeatmap)
#library(DESeq2)
library(ButchR)
#library(ggupset)
#library(clusterProfiler)
#library(msigdbr)
library(umap)
library(cowplot)
library(MatrixGenerics)


```

## NMF of a recovered regulon

Only cells for wich the corresponding cell type was found in scATAC-seq data are taken into account.


## Preprocessing   

Load data and filter out cell 


```{r preprocess,  fig.width=12, fig.height=12, out.width="90%"}

# params <- list(K = 8,
#                p_exprs = 'results/scrna/seurat/rna_seurat_int_annot_transfer.RDS',
#                p_regulon = "results/integrated/TF_activity/regulonAUC.RDS",
#                p_regulonAUC_devCor = "results/integrated/TF_activity/regulonAUC_devCorrected.RDS")



regulon <- regulonByID
dim(regulon)

table(rowSums(regulon) == 0)
table(colSums(regulon) == 0)

exprs <- seuratobjByID
```

## Applying NMF

Applying Non-Negative Matrix Factorization (NMF) to Regulon, using:  
- Factorization ranks from 2 to 8.
- Default NMF method.
- 10 random initialization.

```{r NMF_run, message=FALSE, warning=FALSE, cache=FALSE}
##----------------------------------------------------------------------------##
##                             run NMF                                        ##
##----------------------------------------------------------------------------##
factorization_ranks <- 2:params$maxRank
if (file.exists(params$p_nmf)) {
  norm_nmf_exp <- readRDS(params$p_nmf)
} else {
  
#factorization_ranks <- 7:8
nmf_exp <- run_NMF_tensor(X                     = regulon,
                          ranks                 = factorization_ranks,
                          method                = "NMF",
                          n_initializations     = params$n_initializations,
                          iterations            = 10^4,
                          convergence_threshold = 40,
                          extract_features = TRUE)
nmf_exp

## Normalize NMF
norm_nmf_exp <- normalizeW(nmf_exp)

saveRDS(norm_nmf_exp, params$p_nmf)

}


# 

```
 
 
## Factorization quality metrics and optimal K

Based on the results of the factorization quality metrics, an optimal number of signatures (k) must be chosen:
  
```{r NMF_optK, results='hide',fig.keep='all', message=FALSE, warning=FALSE}
## Plot K stats
gg_plotKStats(norm_nmf_exp)

```
Minize the Frobenius error, the coefficient of variation and the mean Amari distance, while maximizing the sum and mean silhouette width and the cophenic coefficient.
  


## H Matrix sample exposure:  {.tabset}  

Visualization of the sample exposure to the decomposed signatures.
  
  
```{r Hmatrix_Wnorm, fig.width=8, fig.height=5.5, out.width="90%", results='asis', warning=FALSE, message=FALSE}

Heatmap_Regulon <- function(regulon, seurat, title){
  
  #set.seed(1)
  #idx <- sample(colnames(regulon), size=10000, replace=FALSE)
  #regulon <- regulon[,idx]
  
  #colIDs <- c("Gender", "Age", "months_after_acute_phase")
  #colIDs <- c("BioClassification", "Age", "months_after_acute_phase")
  colIDs <- c("Age", "months_after_acute_phase")
  names(colIDs) <- colIDs
  # collist <- lapply(colIDs, function(colID){
  #   type.colVector <- seurat@meta.data[,colID, drop=FALSE] %>% 
  #     dplyr::distinct() %>% 
  #     #dplyr::rename(Celltype =  !!enquo(colID)) %>% 
  #     dplyr::rename(Celltype =  !!colID) %>% 
  #     dplyr::arrange(Celltype) %>% 
  #     dplyr::mutate(color = alphabet.colors(n())) %>% 
  #     deframe()
  # })
  #collist <-  list(months_after_acute_phase = setNames(c("grey10", "grey50", "grey90"), c("0 months", "3 months", "6 months")))
  collist <-  list(months_after_acute_phase = setNames(c("white", "yellow", "black"), c("0 months", "3 months", "6 months")))
  collist$Gender <- setNames(c("grey20", "grey80"), c("f", "m"))
  #circlize::colorRamp2(breaks = seq(from=min(seurat@meta.data$Age), to=max(seurat@meta.data$Age), length.out=10), colors = c("white", "black"))
  collist$Age <- circlize::colorRamp2(breaks = c(min(seurat@meta.data$Age), max(seurat@meta.data$Age)), colors = c("white", "black"))
 
  
  # Build Heatmap annotation
  heat.anno <- HeatmapAnnotation(df  = seurat@meta.data[colnames(regulon),names(collist), drop=FALSE],
                                 col = collist,
                                 #list(predicted.id = type.colVector),
                                 show_annotation_name = TRUE, na_col = "white")
  
  
  rownames(regulon) <- paste0("Sign.", 1:nrow(regulon))
  Heatmap(regulon,
          col = viridis(100),
          name = title,
          top_annotation = heat.anno,
          use_raster = TRUE,
          raster_device = "png",
          show_column_names = FALSE,
          show_row_names = TRUE,
          show_column_dend = FALSE,
          show_row_dend = FALSE,
          cluster_rows = TRUE)
}

##----------------------------------------------------------------------------##
##              Generate H matrix heatmap, W normalized                       ##
##----------------------------------------------------------------------------##
heatmaps_list <- list()
i <- 1
for(ki in factorization_ranks) {
  cat("\n")
  cat("  \n### H matrix for k=",  ki, "  {.tabset}   \n  ")
  #plot H matrix
  tmpHmatrix <- HMatrix(norm_nmf_exp, k = ki)
  h.heatmap <- Heatmap_Regulon(regulon=tmpHmatrix, seurat=exprs, title=paste0("H k=", ki))
  print(h.heatmap)
  heatmaps_list[[i]] <- h.heatmap
  
  h.heatmap <- Heatmap_Regulon(regulon=tmpHmatrix/rowMaxs(tmpHmatrix), seurat=exprs, title=paste0("H k=", ki))
  print(h.heatmap)
  heatmaps_list[[i+1]] <- h.heatmap
  i <- i+2
}


#length(heatmaps_list)
pdf(file = sub(".RDS", "_heatmaps.pdf", params$p_nmf), width=10, height=7)
for (h in heatmaps_list) {
  print(h)
}
dev.off()


```

## Signature estability - Riverplot visualization

Riverplot representation of the extracted signatures at different factorization ranks. The nodes represent the signatures, the edge strength encodes cosine similarity between signatures linked by the edges. 

```{r NMF_river, results='hide',fig.keep='all', message=FALSE, warning=FALSE}
river <- generateRiverplot(norm_nmf_exp, ranks = factorization_ranks)
plot(river, plot_area=1, yscale=0.6, nodewidth=0.5)


pdf(file = sub(".RDS", "_riverplot.pdf", params$p_nmf), width=10, height=7)
plot(river, plot_area=1, yscale=0.6, nodewidth=0.5)
dev.off()


```

