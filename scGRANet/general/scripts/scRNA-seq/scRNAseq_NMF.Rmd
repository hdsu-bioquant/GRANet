---
title: "scRNA-seq NMF"
author: "HDSU"
date: "`r date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    number_sections: false
params:
  K                   : 10
  p_exprs             : '/home/bq_aquintero/10_charite_covid19/results/scrna/seurat/rna_seurat_int_annot_transfer.RDS'
  p_regulon : "results/integrated/TF_activity_5000/regulonAUC_devCorrected.RDS"
  p_nmf : "path"
  annotCol: "tissue"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
#this chunk sets global options for Rmarkdown

knitr::opts_chunk$set(echo = TRUE)
options(knitr.table.format="html")

# if (Sys.info()[["sysname"]] == "Darwin") {
#     # When running locally use conda env
#     reticulate::use_condaenv("tensor240pip", required = TRUE)
#     print(reticulate::py_config())
# }

library(tidyverse)
library(Polychrome)
library(viridis)
library(ComplexHeatmap)
#library(DESeq2)
library(ButchR)
#library(ggupset)
#library(clusterProfiler)
#library(msigdbr)
library(umap)
library(cowplot)
library(MatrixGenerics)
library(Seurat)


```

## NMF of single cell expression data

Using the 2000 hvg

## Preprocessing   

Load data and filter out cell 


```{r preprocess,  fig.width=12, fig.height=12, out.width="90%"}

# params <- list(K = 8,
#                p_exprs = 'results/scrna/seurat/rna_seurat_int_annot_transfer.RDS',
#                p_regulon = "results/integrated/TF_activity_5000/regulonAUC_devCorrected.RDS")


regulon <- readRDS(params$p_regulon)
seuratobj <- readRDS(params$p_exprs)

seuratobjfil <- seuratobj[,colnames(seuratobj) %in% colnames(regulon)]
dim(seuratobjfil)
dim(regulon)



DefaultAssay(seuratobjfil) <- "RNA"
seuratobjfil <- NormalizeData(seuratobjfil, normalization.method = "RC", scale.factor = 1e6)
seuratobjfil <- ScaleData(seuratobjfil, features = rownames(seuratobjfil))
seuratobjfil <- FindVariableFeatures(seuratobjfil, selection.method = "vst", nfeatures = 2000)


hvg <- Seurat::VariableFeatures(seuratobjfil)
X <- Seurat::GetAssayData(seuratobjfil, slot="data")[hvg,]
#X <- Seurat::GetAssayData(seuratobjfil, slot="scale.data")
min(X)
dim(X)
X <- as.matrix(X)
X <- log1p(X)


```

## Applying NMF

Applying Non-Negative Matrix Factorization (NMF), using:  
- Factorization ranks from 2 to 10.
- Default NMF method.
- 10 random initialization.

```{r NMF_run, message=FALSE, warning=FALSE, cache=FALSE}
##----------------------------------------------------------------------------##
##                             run NMF                                        ##
##----------------------------------------------------------------------------##
factorization_ranks <- 2:10
nmf_exp <- run_NMF_tensor(X                     = X,
                          ranks                 = factorization_ranks,
                          method                = "NMF",
                          n_initializations     = 10,
                          iterations            = 10^4,
                          convergence_threshold = 40, 
                          extract_features = TRUE)
nmf_exp
  
## Normalize NMF
norm_nmf_exp <- normalizeW(nmf_exp)
norm_nmf_expH <- normalizeH(nmf_exp)

saveRDS(norm_nmf_exp, params$p_nmf)

```
 
 
## Factorization quality metrics and optimal K

Based on the results of the factorization quality metrics, an optimal number of signatures (k) must be chosen:
  
```{r NMF_optK, results='hide',fig.keep='all', message=FALSE, warning=FALSE}
## Plot K stats
gg_plotKStats(norm_nmf_exp)

```
Minize the Frobenius error, the coefficient of variation and the mean Amari distance, while maximizing the sum and mean silhouette width and the cophenic coefficient.
  


## H Matrix sample exposure:  {.tabset}  

Visualization of the sample exposure to the decomposed signatures.
  
  
```{r Hmatrix_Wnorm, fig.width=8, fig.height=5.5, out.width="90%", results='asis', warning=FALSE, message=FALSE}

Heatmap_Regulon <- function(regulon, seurat, title, colID){
  
  type.colVector <- seurat@meta.data[,colID, drop=FALSE] %>% 
    dplyr::distinct() %>% 
    #dplyr::rename(Celltype =  !!enquo(colID)) %>% 
    dplyr::rename(Celltype =  !!colID) %>% 
    dplyr::arrange(Celltype) %>% 
    dplyr::mutate(color = alphabet.colors(n())) %>% 
    deframe()
  collist <- list(type.colVector) 
  names(collist) <- colID
  
  # Build Heatmap annotation
  heat.anno <- HeatmapAnnotation(df  = seurat@meta.data[colnames(regulon),colID, drop=FALSE],
                                 col = collist,
                                 #list(predicted.id = type.colVector),
                                 show_annotation_name = TRUE, na_col = "white")
  
  Heatmap(regulon,
          col = viridis(100),
          name = title,
          top_annotation = heat.anno,
          show_column_names = FALSE,
          show_row_names = FALSE,
          show_column_dend = FALSE,
          show_row_dend = FALSE,
          cluster_rows = TRUE)
}


##----------------------------------------------------------------------------##
##              Generate H matrix heatmap, W normalized                       ##
##----------------------------------------------------------------------------##
for(ki in factorization_ranks) {
  cat("\n")
  cat("  \n### H matrix for k=",  ki, "  {.tabset}   \n  ")
  #plot H matrix
  tmpHmatrix <- HMatrix(norm_nmf_exp, k = ki)
  h.heatmap <- Heatmap_Regulon(regulon=tmpHmatrix, seurat=seuratobj, title=paste0("H k=", ki), colID=params$annotCol)
  print(h.heatmap)
  
  h.heatmap <- Heatmap_Regulon(regulon=tmpHmatrix/rowMaxs(tmpHmatrix), seurat=seuratobj, title=paste0("H k=", ki), colID=params$annotCol)
  print(h.heatmap)
  }
```

## Signature estability - Riverplot visualization

Riverplot representation of the extracted signatures at different factorization ranks. The nodes represent the signatures, the edge strength encodes cosine similarity between signatures linked by the edges. 

```{r NMF_river, results='hide',fig.keep='all', message=FALSE, warning=FALSE}
river <- generateRiverplot(norm_nmf_exp, ranks = factorization_ranks)
plot(river, plot_area=1, yscale=0.6, nodewidth=0.5)

```


## Cluster identification - UMAP

Cluster identification by running UMAP on the matrix H. 

```{r umap_Hmatrix}
##----------------------------------------------------------------------------##
##                         UMAP H matrix                                      ##
##----------------------------------------------------------------------------##
hmatrix_norm <- HMatrix(norm_nmf_exp, k = params$K)
umapView <- umap(t(hmatrix_norm))

umapView_df <- as.data.frame(umapView$layout)
colnames(umapView_df) <- c("UMAP1", "UMAP2")

umapView_df %>% 
  rownames_to_column("cellID") %>% 
  left_join(rownames_to_column(seuratobj@meta.data, "cellID"), by = "cellID") %>% 
  ggplot(aes(x=UMAP1, y=UMAP2, color = !!sym(params$annotCol))) + 
  geom_point(size = 1.5, alpha = 0.95) + 
  #scale_color_manual(values = type_colVector) +
  cowplot::theme_cowplot()


```

## Association of signatures to biological variables:  {.tabset}  


Recovery plots showing the association of the NMF signatures to known biological variables.
  
  
```{r recovery, fig.width=8, fig.height=5.5, out.width="90%", results='asis', warning=FALSE, message=FALSE}
##----------------------------------------------------------------------------##
##                               Recovery plots                               ##
##----------------------------------------------------------------------------##

annot <- umapView_df %>% 
  rownames_to_column("cellID") %>% 
  left_join(rownames_to_column(seuratobj@meta.data, "cellID"), by = "cellID")

for(ki in factorization_ranks) {
  cat("\n")
  cat("  \n### Recovery plots for k=",  ki, "  {.tabset}   \n  ")
  tmpHmatrix <- HMatrix(norm_nmf_exp, k = ki)
  recov <- ButchR::recovery_plot(tmpHmatrix, annot[, params$annotCol])
  print(recov)
  }
```
